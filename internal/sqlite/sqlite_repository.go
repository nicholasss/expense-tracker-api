// Package sqlite implements the repository interface for the expenses datamodel
package sqlite

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/nicholasss/expense-tracker-api/internal/expenses"
)

// TODO:
// - How should this package handle teardown of the database?

// ErrNilPointer is returned when a nil pointer dereference is avoided
var ErrNilPointer = fmt.Errorf("input pointer cannot be nil")

// QueryError for wrapping sql query errors
type QueryError struct {
	Query string
	Err   error
}

// Error implements the error interface
func (e *QueryError) Error() string { return e.Query + ": " + e.Err.Error() }

// Is is used for errors.Is(), right now with testing
func (e *QueryError) Is(target error) bool { return target == e.Err }

// dbExpense has time stored as unix seconds (not milli-)
type dbExpense struct {
	ID          int
	CreatedAt   int64
	OccuredAt   int64
	Description string
	Amount      int64
}

func toDBExpense(e *expenses.Expense) dbExpense {
	// convert times to int
	return dbExpense{
		ID:          e.ID,
		Description: e.Description,
		Amount:      e.Amount,
		// CreatedAt will occur within the database
		OccuredAt: e.ExpenseOccuredAt.Unix(),
	}
}

func toDomainExpense(db dbExpense) *expenses.Expense {
	return &expenses.Expense{
		ID:               db.ID,
		Description:      db.Description,
		Amount:           db.Amount,
		RecordCreatedAt:  time.Unix(db.CreatedAt, 0),
		ExpenseOccuredAt: time.Unix(db.OccuredAt, 0),
	}
}

type SqliteRepository struct {
	db *sql.DB
}

func NewSqliteRepository(db *sql.DB) *SqliteRepository {
	return &SqliteRepository{db: db}
}

// GetByID find a particular expense with an id
func (r *SqliteRepository) GetByID(ctx context.Context, id int) (*expenses.Expense, error) {
	var dbE dbExpense

	query := `
  SELECT
    id, created_at, occured_at, description, amount
  FROM
    expenses
  WHERE
    id = ?;`

	row := r.db.QueryRowContext(ctx, query, id)
	err := row.Scan(&dbE.ID, &dbE.CreatedAt, &dbE.OccuredAt, &dbE.Description, &dbE.Amount)
	if err == sql.ErrNoRows {
		return nil, &QueryError{Query: query, Err: err}
	}
	if err != nil {
		return nil, err
	}

	// perform conversion to domain expense as last step
	return toDomainExpense(dbE), nil
}

// GetAll returns a list of all expenses in the database
func (r *SqliteRepository) GetAll(ctx context.Context) ([]*expenses.Expense, error) {
	query := `
  SELECT
    id, created_at, occured_at, description, amount
  FROM
    expenses;`

	rows, err := r.db.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}

	// deferred but still checking error
	defer func() {
		closeErr := rows.Close()
		if err == nil && closeErr != nil {
			err = fmt.Errorf("failed to close query rows: %w", closeErr)
		}
	}()

	// get all rows from query
	dbExpenses := make([]dbExpense, 0)
	for rows.Next() {
		var dbE dbExpense
		err = rows.Scan(&dbE.ID, &dbE.CreatedAt, &dbE.OccuredAt, &dbE.Description, &dbE.Amount)
		if err != nil {
			return nil, err
		}

		dbExpenses = append(dbExpenses, dbE)
	}

	// check for errors from sql query
	if err = rows.Err(); err == sql.ErrNoRows {
		return nil, &QueryError{Query: query, Err: err}
	} else if err != nil {
		return nil, err
	}

	expenses := make([]*expenses.Expense, 0)
	for _, dbE := range dbExpenses {
		expenses = append(expenses, toDomainExpense(dbE))
	}

	return expenses, nil
}

// Create creates a new expense and returns it with id and createdAt
func (r *SqliteRepository) Create(ctx context.Context, exp *expenses.Expense) (*expenses.Expense, error) {
	if exp == nil {
		return nil, ErrNilPointer
	}

	insertDBE := toDBExpense(exp)

	query := `
  INSERT INTO
    expenses
      (
        created_at,
        occured_at,
        description,
        amount
      )
  VALUES
    (
      unixepoch(),
      ?,
      ?,
      ?
    )
  RETURNING *;`

	// ID is generated by the db so we ignore it when inserting
	row := r.db.QueryRowContext(ctx, query,
		insertDBE.OccuredAt, insertDBE.Description, insertDBE.Amount,
	)

	var returnDBE dbExpense
	err := row.Scan(
		&returnDBE.ID, &returnDBE.CreatedAt, &returnDBE.OccuredAt,
		&returnDBE.Description, &returnDBE.Amount,
	)
	if err != nil {
		return nil, err
	}

	return toDomainExpense(returnDBE), nil
}

// Update performs a full update for occuredAt, description, and amount
// It does not return the updated expense struct since id and createdAt do not change
func (r *SqliteRepository) Update(ctx context.Context, exp *expenses.Expense) error {
	if exp == nil {
		return ErrNilPointer
	}

	insertDBE := toDBExpense(exp)

	query := `
  UPDATE
    expenses
  SET
    occured_at = ?,
    description = ?,
    amount = ?
  WHERE
    id = ?;`

	_, err := r.db.ExecContext(ctx, query,
		insertDBE.OccuredAt, insertDBE.Description, insertDBE.Amount, insertDBE.ID,
	)
	if err != nil {
		return err
	}

	return nil
}

func (r *SqliteRepository) Delete(ctx context.Context, id int) error {
	query := `
  DELETE FROM
    expenses
  WHERE
    id = ?;`

	_, err := r.db.ExecContext(ctx, query, id)
	if err != nil {
		return err
	}

	return nil
}
