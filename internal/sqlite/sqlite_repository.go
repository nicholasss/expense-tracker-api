// Package sqlite implements the repository interface for the expenses datamodel
package sqlite

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/nicholasss/expense-tracker-api/internal/expenses"
)

// QueryError for wrapping sql query errors
type QueryError struct {
	Query string
	Err   error
}

// Error implements the error interface
func (e *QueryError) Error() string {
	return fmt.Sprintf("%s: %v", e.Query, e.Err)
}

// Unwrap implementing for errors.Is()
func (e *QueryError) Unwrap() error { return e.Err }

// NewQueryError is a factory method
func NewQueryError(query string, err error) *QueryError {
	return &QueryError{Query: query, Err: err}
}

// sqliteExpense has time stored as unix seconds (not milli-)
type sqliteExpense struct {
	ID          int
	CreatedAt   int64
	OccuredAt   int64
	Description string
	Amount      int64
}

func toSqliteExpense(e *expenses.Expense) sqliteExpense {
	// convert times to int
	return sqliteExpense{
		ID:          e.ID,
		Description: e.Description,
		Amount:      e.Amount,
		// CreatedAt will occur within the database
		OccuredAt: e.ExpenseOccuredAt.Unix(),
	}
}

func toServiceExpense(db sqliteExpense) *expenses.Expense {
	return &expenses.Expense{
		ID:               db.ID,
		Description:      db.Description,
		Amount:           db.Amount,
		RecordCreatedAt:  time.Unix(db.CreatedAt, 0),
		ExpenseOccuredAt: time.Unix(db.OccuredAt, 0),
	}
}

type SqliteRepository struct {
	DB *sql.DB
}

func NewSqliteRepository(dbDriver, database string) (*SqliteRepository, error) {
	db, err := sql.Open(dbDriver, database)
	if err != nil {
		return nil, err
	}

	return &SqliteRepository{DB: db}, nil
}

// GetByID find a particular expense with an id
func (r *SqliteRepository) GetByID(ctx context.Context, id int) (*expenses.Expense, error) {
	var dbE sqliteExpense

	query := `
  SELECT
    id, created_at, occured_at, description, amount
  FROM
    expenses
  WHERE
    id = ?;`

	row := r.DB.QueryRowContext(ctx, query, id)
	err := row.Scan(&dbE.ID, &dbE.CreatedAt, &dbE.OccuredAt, &dbE.Description, &dbE.Amount)
	if err == sql.ErrNoRows {
		return nil, NewQueryError(query, err)
	}
	if err != nil {
		return nil, err
	}

	// perform conversion to domain expense as last step
	return toServiceExpense(dbE), nil
}

// GetAll returns a list of all expenses in the database
func (r *SqliteRepository) GetAll(ctx context.Context) ([]*expenses.Expense, error) {
	query := `
  SELECT
    id, created_at, occured_at, description, amount
  FROM
    expenses;`

	rows, err := r.DB.QueryContext(ctx, query)
	if err != nil {
		return nil, err
	}

	// deferred but still checking error
	defer func() {
		closeErr := rows.Close()
		if err == nil && closeErr != nil {
			err = fmt.Errorf("failed to close query rows: %w", closeErr)
		}
	}()

	// get all rows from query
	dbExpenses := make([]sqliteExpense, 0)
	for rows.Next() {
		var dbE sqliteExpense
		err = rows.Scan(&dbE.ID, &dbE.CreatedAt, &dbE.OccuredAt, &dbE.Description, &dbE.Amount)
		if err != nil {
			return nil, err
		}

		dbExpenses = append(dbExpenses, dbE)
	}

	// check for errors from sql query
	if err = rows.Err(); err == sql.ErrNoRows {
		return nil, &QueryError{Query: query, Err: err}
	} else if err != nil {
		return nil, err
	}

	expenses := make([]*expenses.Expense, 0)
	for _, dbE := range dbExpenses {
		expenses = append(expenses, toServiceExpense(dbE))
	}

	return expenses, nil
}

// Create creates a new expense and returns it with id and createdAt
func (r *SqliteRepository) Create(ctx context.Context, exp *expenses.Expense) (*expenses.Expense, error) {
	if exp == nil {
		return nil, expenses.ErrNilPointer
	}

	insertDBE := toSqliteExpense(exp)

	query := `
  INSERT INTO
    expenses
      (
        created_at,
        occured_at,
        description,
        amount
      )
  VALUES
    (
      unixepoch(),
      ?,
      ?,
      ?
    )
  RETURNING *;`

	// ID is generated by the db so we ignore it when inserting
	row := r.DB.QueryRowContext(ctx, query,
		insertDBE.OccuredAt, insertDBE.Description, insertDBE.Amount,
	)

	var returnDBE sqliteExpense
	err := row.Scan(
		&returnDBE.ID, &returnDBE.CreatedAt, &returnDBE.OccuredAt,
		&returnDBE.Description, &returnDBE.Amount,
	)
	if err != nil {
		return nil, err
	}

	return toServiceExpense(returnDBE), nil
}

// Update performs a full update for occuredAt, description, and amount
// It does not return the updated expense struct since id and createdAt do not change
func (r *SqliteRepository) Update(ctx context.Context, exp *expenses.Expense) error {
	if exp == nil {
		return expenses.ErrNilPointer
	}

	insertDBE := toSqliteExpense(exp)

	query := `
  UPDATE
    expenses
  SET
    occured_at = ?,
    description = ?,
    amount = ?
  WHERE
    id = ?;`

	res, err := r.DB.ExecContext(ctx, query,
		insertDBE.OccuredAt, insertDBE.Description, insertDBE.Amount, insertDBE.ID,
	)
	if err != nil {
		return err
	}

	rowsUpdated, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if rowsUpdated == 0 {
		return expenses.ErrNoRowsUpdated
	}
	return nil
}

func (r *SqliteRepository) Delete(ctx context.Context, id int) error {
	query := `
  DELETE FROM
    expenses
  WHERE
    id = ?;`

	res, err := r.DB.ExecContext(ctx, query, id)
	if err != nil {
		return err
	}

	rowsAffected, err := res.RowsAffected()
	if err != nil {
		return err
	}

	if rowsAffected == 0 {
		return expenses.ErrNoRowsDeleted
	}

	return nil
}
